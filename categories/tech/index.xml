<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tech on 一间茅庐</title><link>https://maolu.one/categories/tech/</link><description>Recent content in Tech on 一间茅庐</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 07 Jul 2020 16:01:23 +0800</lastBuildDate><atom:link href="https://maolu.one/categories/tech/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Github Pages 的两个小技巧</title><link>https://maolu.one/posts/two-tricks-on-github-pages/</link><pubDate>Tue, 07 Jul 2020 16:01:23 +0800</pubDate><guid>https://maolu.one/posts/two-tricks-on-github-pages/</guid><description>&lt;p>将博客切换到 Hugo 之后，我使用 Github Pages 部署生成的静态网站文件。本文介绍使用 Github Pages 的两个小技巧。&lt;/p>
&lt;h2 id="一绑定域名到-github-pages-的正确姿势">一、绑定域名到 Github Pages 的正确姿势&lt;/h2>
&lt;p>&lt;strong>假设你的 Github Pages 地址为 &lt;!-- raw HTML omitted -->username.github.io&lt;!-- raw HTML omitted -->。&lt;/strong>&lt;/p>
&lt;p>如果你想要绑定的是二级域名，比如 &lt;!-- raw HTML omitted -->&lt;strong>blog.maolu.one&lt;/strong>&lt;!-- raw HTML omitted -->，则需要以下两个步骤：&lt;/p>
&lt;ol>
&lt;li>在仓库的根目录创建文件，文件名：&lt;code>CNAME&lt;/code> ，文件内容：&lt;code>blog.maolu.one&lt;/code> ;&lt;/li>
&lt;li>给域名添加 CNAME 记录，记录名：&lt;code>blog&lt;/code>，记录值：&lt;code>username.github.io&lt;/code> 。&lt;/li>
&lt;/ol>
&lt;p>按照以上步骤绑定的二级域名，等待 Github 自动签发好 Let&amp;rsquo;s Encrypt 证书后，可以正常在仓库的 &lt;code>Settings &amp;gt; Github Pages&lt;/code> 中开启 &lt;code>Enforce HTTPS&lt;/code> 选项。对于没有强迫症（不需要开启 Enforce HTTPS 功能），且域名管理服务商支持 CNAME Flattening 的人，也可以按照上述方法绑定根域名，CNAME 记录名为 @。&lt;/p>
&lt;p>如果你想使用正确姿势绑定是根域名，比如 &lt;!-- raw HTML omitted -->&lt;strong>maolu.one&lt;/strong>&lt;!-- raw HTML omitted -->，就会稍微复杂一些。&lt;/p>
&lt;ol>
&lt;li>在仓库的根目录创建文件，文件名：&lt;code>CNAME&lt;/code> ，文件内容：&lt;code>maolu.one&lt;/code> ;&lt;/li>
&lt;li>给根域名添加 4 个 A 记录，记录名：&lt;code>@&lt;/code>，记录值分别为：185.199.108.153、185.199.109.153、185.199.110.153、185.199.111.153。这些 IP 地址有可能会改变，但频率应该会很低&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> 。&lt;/li>
&lt;li>如果你的 www A 记录没有其他用处，建议添加 CNAME 记录名 www，值为 &lt;code>username.github.io&lt;/code> 。&lt;/li>
&lt;/ol>
&lt;p>不论哪种类型的域名，仓库根目录的 CNAME 文件的设置会覆盖仓库的 &lt;code>Settings &amp;gt; Github Pages&lt;/code> 中的域名设置。所以如果你在 Setting 中设置了域名，却没有 CNAME 文件，则该设置过一会儿就失效了。&lt;/p>
&lt;p>如果你的 Github Pages 中的内容是用静态网站生成器生成的，需要注意在每次提交时，是否会移除 CNAME 文件。以 Hugo 为例，在 /static 目录中新增 CNAME 文件是最为保险的方式，因为不论如何提交，都会在网站的根目录也就是仓库的根目录生成此文件。&lt;/p>
&lt;h2 id="二同一个账号开通多个-github-pages">二、同一个账号开通多个 Github Pages&lt;/h2>
&lt;p>有很多教程中提到一个 Github 账户只能创建一个 Github Pages 仓库，这样的说法是不对的。因为除了通过创建 username.github.io 来自动创建 Github Pages 仓库的方式，还有其他方式创建 Github Pages 仓库：&lt;/p>
&lt;ol>
&lt;li>创建一个普通公开仓库，名称随意。这里假设名称为 &lt;code>another.repo&lt;/code> ；&lt;/li>
&lt;li>在该仓库中，新增 gh-pages 分支，并将代码提交到此分支；此时，你就拥有了另外一个 Github Pages 仓库了，其网址为 &lt;code>username.github.io/another.repo&lt;/code> ；&lt;/li>
&lt;li>如同前文提到的绑定域名的方式一样，创建 CNAME 文件、增加 DNS 记录就可以绑定域名。&lt;/li>
&lt;/ol>
&lt;p>多个仓库绑定域名的方式如下图所示：&lt;/p>
&lt;p>&lt;img src="https://images.maolu.one/20200707173114.png" alt="多个 Github Pages 绑定域名">&lt;/p>
&lt;p>有了多个仓库，我们就可以不需要新建 Github 账号，创建另外的 Github Pages 仓库存放图片、脚本等内容，方便使用 Markdown 写文章时调用&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a href="https://docs.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain" target="_blank" >Configuring an apex domain&lt;/a> &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>例如：&lt;a href="https://molunerfinn.com/typora-supports-picgo/" target="_blank" >Typora 支持 PicGo 来上传图片了&lt;/a> &lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>博客切换到 Hugo 的一些记录</title><link>https://maolu.one/posts/switch-blog-to-hugo/</link><pubDate>Mon, 06 Jul 2020 22:37:41 +0800</pubDate><guid>https://maolu.one/posts/switch-blog-to-hugo/</guid><description>&lt;p>因为实在是喜爱当前的这个主题&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> ，所以这两天将博客改为 Hugo 系统，并且托管在 Github Pages 上，一年还能省四五百块大洋。初次接触 Hugo，颤颤巍巍、如履薄冰，不过最终还是将其搭建并部署起来了。今天基本完善，记录一下中间遇到的一些问题。&lt;/p>
&lt;h2 id="一hugo-主题的使用">一、Hugo 主题的使用&lt;/h2>
&lt;p>如果你在 Hugo 的 Git 根目录中使用 &lt;code>git clone&lt;/code> 某个主题到 Hugo 的 themes 目录下，则你在部署到 Github 的时候会遇到问题。例如我现在使用的主题：&lt;/p>
&lt;pre>&lt;code>$ git clone git@github.com:joway/hugo-theme-yinyang.git themes/yinyang
&lt;/code>&lt;/pre>&lt;p>当你想要部署到 Github 时，会提示一个 Git 中包含了另一个 Git，无法处理。所以在使用 Github 上的主题时，不要使用 &lt;code>git clone&lt;/code> ，而要使用 &lt;code>git submodule add&lt;/code> ：&lt;/p>
&lt;pre>&lt;code>$ git clone git@github.com:joway/hugo-theme-yinyang.git themes/yinyang
&lt;/code>&lt;/pre>&lt;h2 id="二使用-github-actions-自动化部署">二、使用 Github Actions 自动化部署&lt;/h2>
&lt;p>如果你愿意，可以在本地使用 &lt;code>hugo&lt;/code> 命令生成静态文件到 public 目录，再将 public 目录提交到你的 Github Pages 页面。其实这样也不太繁琐，问题是网站程序的源代码没有使用 Github 上，再多台设备上写博客就不太方便了。而且显然源代码和文章的 &lt;code>.md&lt;/code> 文件托管到 Github 上几乎没有丢失的风险，安全性更好。&lt;/p>
&lt;p>我认可的方式是使用两个 Git 仓库来部署，一个私有仓库存放源代码，一个公开的 Github Pages 仓库存放静态页面，具体的方式可以自行搜索&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> 。&lt;/p>
&lt;h2 id="三rss-相关">三、RSS 相关&lt;/h2>
&lt;p>Hugo 默认的 RSS 功能至少存在一下两个问题：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>没有控制 RSS 输出的条目数量；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>RSS 为纯文本，且内容过短。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>RSS 输出的条目数量，可以通过在配置文件 &lt;code>config.toml&lt;/code> 中增加以下配置控制：&lt;/p>
&lt;pre>&lt;code>[services.rss]
limit = 15
&lt;/code>&lt;/pre>&lt;p>RSS 内容过短，原因是 Hugo 默认的 RSS 条目显示的是摘要，默认的摘要长度为 70 个&lt;strong>单词&lt;/strong>，中文没有单词的概念，所以 RSS 输出的条目内容会极短。在 &lt;code>config.toml&lt;/code> 中增加以下配置解决中文长度计算的问题，并且自定义摘要长度：&lt;/p>
&lt;pre>&lt;code>hasCJKLanguage = true
summaryLength = 200
&lt;/code>&lt;/pre>&lt;p>注意：设置 &lt;code> hasCJKLanguage = true&lt;/code> 后，部分主题会收到一些影响，需自行尝试。&lt;/p>
&lt;p>而想要将 RSS 输出为全文且包含格式，则需要覆盖默认的 RSS 模版。&lt;/p>
&lt;ol>
&lt;li>新建 &lt;code>/layout/_default/rss.xml&lt;/code> 文件；&lt;/li>
&lt;li>将 hugo 默认的 rss.xml 模版&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> 填充到刚刚建立的 rss.xml 中；&lt;/li>
&lt;li>修改填充好的 rss.xml，将 &lt;code>&amp;lt;description&amp;gt;{{ .Summary | html }}&amp;lt;/description&amp;gt;&lt;/code> 修改为 &lt;code>&amp;lt;description&amp;gt;{{ .Content | html }}&amp;lt;/description&amp;gt;&lt;/code> 。&lt;/li>
&lt;/ol>
&lt;p>通过这样的模版修改，可以实现更多的自定义功能。比如你更想输出纯文本的摘要，但希望在摘要后面增加“&amp;hellip;阅读更多”链接，可以通过修改 &lt;code>&amp;lt;description&amp;gt;&lt;/code> 段为：&lt;/p>
&lt;pre>&lt;code>&amp;lt;description&amp;gt;
{{ .Summary }}{{ print &amp;quot;...&amp;quot; }}
{{ print &amp;quot;&amp;lt;p&amp;gt;&amp;lt;a href=\&amp;quot;&amp;quot; }}{{ .Permalink }}{{ print &amp;quot;\&amp;quot;&amp;gt;查看原文&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&amp;quot; }}
&amp;lt;/description&amp;gt;
&lt;/code>&lt;/pre>&lt;p>我对 Hugo 的模版语言非常不了解，所以其他自定义方式就没有再探寻。&lt;/p>
&lt;h2 id="四让链接在新标签页中打开">四、让链接在新标签页中打开&lt;/h2>
&lt;p>Markdown 无法定义链接是否在新标签页中打开，所以 Hugo 渲染出的博客文章中，链接全部都是在当前标签页中打开。要解决此问题，也需要对对模版进行一定的 hack。&lt;/p>
&lt;ol>
&lt;li>新建 &lt;code>/layout/_default/_markup/render-link.html&lt;/code> 文件&lt;/li>
&lt;li>在该文件中填充以下内容：&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>&amp;lt;a href=&amp;quot;{{ .Destination | safeURL }}&amp;quot; {{ with .Title}} title=&amp;quot;{{ . }}&amp;quot;
{{ end }}{{ if strings.HasPrefix .Destination &amp;quot;http&amp;quot; }} target=&amp;quot;_blank&amp;quot; {{ end }}&amp;gt;{{ .Text }}&amp;lt;/a&amp;gt;
&lt;/code>&lt;/pre>&lt;p>如此修改后，链接就都是在新标签页中打开了。&lt;/p>
&lt;h2 id="五hugo-评论-disqus-配置">五、Hugo 评论 Disqus 配置&lt;/h2>
&lt;p>如果你的主题支持 Disqus，则可以在 Hugo 中使用 Disqus 评论系统。使用 Disqus 一般需要让你在配置文件中增加 Disqus shortname 配置，刚开始我以为 shortname 就是 Disqus 账户的 Username，所以一直没成功。后面才发现 shortname 是需要去 Disqus 网站开通 Your Site 功能&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> 才能获取和定义的。获取 Disqus shortname 后，在配置文件中增加以下配置即可：&lt;/p>
&lt;pre>&lt;code>[params]
disqus = &amp;quot;your_disqus_shortname&amp;quot;
&lt;/code>&lt;/pre>&lt;h2 id="六文章中图片处理">六、文章中图片处理&lt;/h2>
&lt;p>如果不使用第三方的图片服务，那么需要将图片放置到 /static 目录下，这样就能通过类似 &lt;code>https://yourblog.com/image_name.jpg&lt;/code> 的网址访问到。/static 目录也支持子目录。&lt;/p>
&lt;p>如果你使用 Typora 编辑器编辑 Markdown 文件，则可以使用集成的图片上传功能上传图片到第三方图片服务器上。&lt;/p>
&lt;p>&lt;img src="https://images.maolu.one/20200707001731.png" alt="">&lt;/p>
&lt;p>具体如何配置，请参看 &lt;em>Typora 支持 PicGo 来上传图片了&lt;/em>&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup> 。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在这次转换过程中，还遇到了很多问题，有些解决了，有些没解决。总体感觉：&lt;/p>
&lt;ol>
&lt;li>Hugo 的模版很精美，也很实用。我本来不太想换到 Hugo，但上周发现的这个主题对我的诱惑太大了。&lt;/li>
&lt;li>WordPress 是全能的发布平台，Hugo 则非常轻量化。虽然 WordPress 全能，但并不意味着入门难。因为一方面文档齐全且用户量大，可以搜索到的教程也多；另一方面，PHP + MySQL，程序 + 数据库的模式也深入人心；第三是 WordPress 有体验不错的管理后台和文章编辑器，写文章发文章比较简单；最后是 PHP 的广泛影响力，虽然现在有很多新的“更好的”编程语言，但毕竟“PHP 是最好的语言”。Hugo 则更适合有一定编程经验和运维经验的人使用。&lt;/li>
&lt;li>Hugo 还很年轻。文档读起来不那么顺，更新也不是很及时。其作者 bep 倒是经常在 hugo 社区回复问题，这解决了一部分文档更新不及时的问题。&lt;/li>
&lt;/ol>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a href="https://github.com/joway/hugo-theme-yinyang" target="_blank" >YinYang is a black-white theme for Hugo.&lt;/a> &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>例如：&lt;a href="https://zhuanlan.zhihu.com/p/109057290" target="_blank" >折腾Hugo | GitHub Pages | Github Actions自动构建发布免费个人网站&lt;/a> ，但此文章有一些错误，例如脚本中对 &lt;code>actions/checkout@v1&lt;/code> 其实可以是 &lt;code>actions/checkout@v2&lt;/code> ，另外 ``deploy_key` 也前后不一致，需要注意。 &lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>&lt;a href="https://github.com/gohugoio/hugo/blob/master/tpl/tplimpl/embedded/templates/_default/rss.xml" target="_blank" >Hugo 默认的 rss.xml 模版&lt;/a> &lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>&lt;a href="https://disqus.com/admin/create/" target="_blank" >创建 Disqus 站点&lt;/a> &lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p>&lt;a href="https://molunerfinn.com/typora-supports-picgo/" target="_blank" >Typora 支持 PicGo 来上传图片了&lt;/a> &lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>使用 rsync 备份群晖资料到 VPS</title><link>https://maolu.one/posts/backup-synogy-to-vps-using-rsync/</link><pubDate>Tue, 16 Jun 2020 11:16:23 +0800</pubDate><guid>https://maolu.one/posts/backup-synogy-to-vps-using-rsync/</guid><description>&lt;p>虽然家里的群晖做了 RAID 1，但看到有帖子说有人家里火灾导致 NAS 的热备份和硬盘的冷备份全部丢失，再加上最近在家赋闲，又想着折腾一番。&lt;/p>
&lt;h2 id="一为什么要使用-vps-作为备份目的地">一、为什么要使用 VPS 作为备份目的地&lt;/h2>
&lt;p>首先，我需要 500GB 以上的存储容量。市面上有很多选择，比如：&lt;/p>
&lt;ul>
&lt;li>大公司做个人和企业云存储的服务，例如 Microsoft OneDrive（1TB $69.99/年）、Google One（2 TB $100/年） 等；&lt;/li>
&lt;li>文件同步备份类型，如 Dropbox（2TB $119.88/年） 等；&lt;/li>
&lt;li>小公司专业做备份的，如 CrashPlan（无限容量 $120/年） 等；&lt;/li>
&lt;li>云计算公司的对象存储，如亚马逊和阿里巴巴对象存储等，此类存储空间、进出流量、请求次数都要收费，仅计算存储空间费用，以阿里巴巴为例，500GB 的存储空间一年就需要 $70.2。&lt;/li>
&lt;/ul>
&lt;p>大部分服务对于我来说太贵了，因为他们提供了更多的价值，例如版本控制，或者数不清几个 9 的服务保证。而我不想为这些额外的功能付费。唯一价格不错的，是 Onedrive。但群晖的 CloudSync 对 Onedrive 的支持似乎有问题，目前我尚未解决此问题，似乎与账号有关。若能找到 6 个人合买 Microsoft 365，那价格的优势就很大（特别是，如果你选择中国区的话），显然我也有动力全力解决此问题。（已确认是账号问题，更换账号后能关联账户，但测试了一下速度只有几百 KB/s，所以暂时不考虑。）&lt;/p>
&lt;p>我选择的 Alpha VPS，位于保加利亚，1 TB 存储空间，每月 3TB 流量，每年只需要 60 欧元（约 $68）。如果选择更低的容量，则价格会更便宜。虽然 VPS 完全是裸机，没有附加功能（除非你愿意去学习一些软件的配置），但因为有 RAID 1 和移动硬盘的冷备份，对安全性要求没那么高，所以对于单纯的异地备份来说已经够用了。经过一天的测试，上传速度有 1.x MB/S，已经超过我的预期了，毕竟服务器在保加利亚那么遥远的地方。&lt;/p>
&lt;h2 id="二如何在群晖上创建备份文件">二、如何在群晖上创建备份文件&lt;/h2>
&lt;p>为了存取方便，需要将每个图片文件夹分别打包，这样上传和下载都比较方便。但我之前的目录命名中有一些有空格，用脚本处理起来有些困难。所以就有了本文中两段小脚本。&lt;/p>
&lt;p>批量移除文件名中的空格：&lt;/p>
&lt;pre>&lt;code>for loop in ls -1 | tr ' ' '#'
do
mv &amp;quot;echo $loop | sed 's/#/ /g'&amp;quot; &amp;quot;echo $loop |sed 's/#//g'&amp;quot; 2&amp;gt; /dev/null
done
&lt;/code>&lt;/pre>&lt;p>然后再使用 tar 将目录分别打包即可：&lt;/p>
&lt;pre>&lt;code>for dir in $(ls | grep -v '@')
do
if [ -d $dir ]&amp;amp;&amp;amp;[ &amp;quot;$dir&amp;quot;x != photobackupx ]
then
tar -cvf $dir.tar $dir/ --exclude @eaDir --exclude .DS_Store --exclude Thumbs.db
fi
done
&lt;/code>&lt;/pre>&lt;p>上面 ls 后 grep -v 是为了去除文件名包含 @ 字符的文件或目录。tar 后跟的 –exclude 也是一样。这些要去除的都是群晖或者 macOS 的一些烦人的玩意儿。当然，如果需要增强安全性，可以使用 zip 或者 p7zip 创建有密码的包，例如：&lt;/p>
&lt;pre>&lt;code>for dir in $(ls);
do
if [ -d $dir ]
then
zip -r0P password $dir.zip ./$dir/
fi
done
&lt;/code>&lt;/pre>&lt;h2 id="三如何将备份文件上传到-vps">三、如何将备份文件上传到 VPS&lt;/h2>
&lt;p>因为数据量有数百 GB，所以传输这些文件遇到了一些问题。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>SCP。 SCP 不支持断点续传，且如果需要批量上传的话，需要再写脚本（今天才知道 SCP 支持目录上传），对于大文件来讲，99% 中断掉的话难以接受。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Resilio Sync。Tracker 服务器（如果可以这么称呼的话）已被关注，无法直接链接。且尝试了一下，速度不是很稳定。而且此应用可能被识别为 P2P 程序，服务商不允许。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>minio。高大上，但过于复杂，我没有学会如何通过命令行或者接口上传，开着网页上传非常不稳定。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>今天尝试了一下传说中的 rsync，因为我是首次同步，SSH 到群晖上，只需要一条命令即可：&lt;/p>
&lt;pre>&lt;code>$ rsync -avuP ./ root@remote_server_ip:~/PhotoBackup
&lt;/code>&lt;/pre>&lt;p>-a 表示已归档方式，-v 显示进度，-u 表示不覆盖已存在的文件，-P 表示支持断点续传。rsync 命令格式与 SCP 基本类似。一般服务器系统都预装了 rsync，没想到群晖系统也内置了 rsync，可见此程序的使用范围非常广泛。这次只是使用了它极为基础的功能，后续也可以设置定时任务来做增量同步功能。&lt;/p></description></item><item><title>解决 Lean 固件编译后无 SSR-Plus 的问题</title><link>https://maolu.one/posts/add-ssr-plus-in-lean-openwrt-firmware/</link><pubDate>Tue, 19 May 2020 12:43:21 +0800</pubDate><guid>https://maolu.one/posts/add-ssr-plus-in-lean-openwrt-firmware/</guid><description>&lt;p>在最近的更新后，Lean 源码中删除了 SSR Plus + 功能模块。在编译路由器固件过程中，进入 Luci-Application 菜单后，找不到 luci-app-ssr-plus 选项，当然也就无法编译这一模块。&lt;/p>
&lt;p>如果是初次编译，git clone 完成后，修改 feeds.conf.default 文件，将：&lt;/p>
&lt;pre>&lt;code># src-git helloworld https://github.com/fw876/helloworld
&lt;/code>&lt;/pre>&lt;p>前面的 # 去掉，修改为：&lt;/p>
&lt;pre>&lt;code>src-git helloworld https://github.com/fw876/helloworld
&lt;/code>&lt;/pre>&lt;p>再进行 &lt;code>make menuconfig&lt;/code> 等命令进行编译即可。&lt;/p>
&lt;p>如果是二次编译，则执行以下命令：&lt;/p>
&lt;pre>&lt;code>$ git pull
$ rm -rf ./tmp &amp;amp;&amp;amp; rm -rf .config
&lt;/code>&lt;/pre>&lt;p>再编辑 feeds.config.default 文件，将 helloworld 一行前的 # 去掉。然后更新 feeds：&lt;/p>
&lt;pre>&lt;code>$ ./scripts/feeds clean
$ ./scripts/feeds update -a &amp;amp;&amp;amp; ./scripts/feeds install -a
&lt;/code>&lt;/pre>&lt;p>再进行 &lt;code>make menuconfig&lt;/code> 等命令进行编译即可。&lt;/p></description></item><item><title>UBNT ER-X 刷 Open-WRT 并作为透明网关</title><link>https://maolu.one/posts/openwrt-on-erx-for-transparent-gateway/</link><pubDate>Tue, 07 Apr 2020 13:04:01 +0800</pubDate><guid>https://maolu.one/posts/openwrt-on-erx-for-transparent-gateway/</guid><description>&lt;p>一直想在家庭网络中增加一个透明网关，达到让网络中所有设备在访问国外网站时自动使用代理的功能。家中本身有一个 3215U + 4 千兆网口的工控机，但嫌弃其电源实在占位置所以没启用。最近才觉察到 UniFi Switch 8 POE 150W 的网口是可以自定义 PoE+ 或 24V Passive PoE 供电的，因为 ER-X 本身体积就小，又支持 24V Passive PoE 供电，这样就可以节省充电器和充电线，仅用一根网线即可供电和数据传输，简约而不简单。&lt;/p>
&lt;h2 id="一编译-er-x-open-wrt-固件">一、编译 ER-X Open-WRT 固件&lt;/h2>
&lt;p>因为官方 Open-WRT 的固件内容比较素，缺乏必备的 ShadowsocksR Plus 等插件，所以我采用 Lean 的 Open-WRT 固件自行编译。编译此固件是需要编译机可无障碍访问国外部分网站，在虚拟机上使用：&lt;/p>
&lt;pre>&lt;code>$ export all_proxy=&amp;quot;socks5://your.proxy:1080&amp;quot;
&lt;/code>&lt;/pre>&lt;p>尝试编译，依然失败，提示有文件无法下载。所以我最终采用在一台 Google Cloud Engine 机器上编译。编译时按照指引，在 make menuconfig 时：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Target System 选择 MediaTek Ralink MIPS&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Subtarget 选择 MT7621 based boards&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Target Profile 选择 EdgeRouter X&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>其余选项不需要动，除非你明白为什么需要动。其他默认参数已经包含了 ShadowsocksR Plus、Adbyby Plus+、KMS服务器等常用功能。&lt;/p>
&lt;p>在最近的更新后，Lean 源码中删除了 SSR Plus + 功能模块。请参考此文做一些修改：解决 Lean 固件编译后无 SSR-Plus + 的问题&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>编译好的固件位于 /lede/bin/targets/ramips/mt7621 目录下。可使用以下语句将其下载到本地：&lt;/p>
&lt;pre>&lt;code>// 自行修改 username、ip、/path/to/lede、/path/to/destination
// kernel
$ scp username@ip:/path/to/lede/bin/targets/ramips/mt7621/openwrt-ramips-mt7621-ubiquiti_edgerouterx-initramfs-kerne.bin /path/to/destination
// firmware
$ scp username@ip:/path/to/lede/bin/targets/ramips/mt7621/openwrt-ramips-mt7621-ubiquiti_edgerouterx-squashfs-sysupgrade.bin /path/to/destination
&lt;/code>&lt;/pre>&lt;h2 id="二将-open-wrt-刷入-er-x">二、将 Open-WRT 刷入 ER-X&lt;/h2>
&lt;p>参考 Open-WRT 官网的教程，很容易即可将 Open-WRT 刷入ER-X。主要需要两步，一是将官方固件刷写为 Open-WRT 的 Kernel，我称之为过渡固件；而是从过渡固件刷写为正式固件。&lt;/p>
&lt;pre>&lt;code>// 上传并刷写过渡固件，假设 ER-X IP 为 192.168.1.1，自行替换 /path/to
$ scp /path/to/openwrt-ramips-mt7621-ubnt-erx-initramfs-kernel.bin ubnt@192.168.1.1:/tmp
$ ssh ubnt@192.168.1.1
ubnt@ubnt:~$ cd /tmp
ubnt@ubnt:/tmp$ add system image openwrt-ramips-mt7621-ubnt-erx-initramfs-kernel.bin
Checking upgrade image...Done
Preparing to upgrade...Done
Copying upgrade image.../usr/bin/ubnt-upgrade: line 509: [: too many arguments
Done
Removing old image...Done
Checking upgrade image...Done
Copying config data...Done
Finishing upgrade...Done
Upgrade completed
ubnt@ubnt:/tmp$ show system image
The system currently has the following image(s) installed:
ramips Bleeding Edge r49395 (default boot)
v1.7.1.4821926.151103.1114 (running image)
A reboot is needed to boot default image
&lt;/code>&lt;/pre>&lt;p>如果刷写时，出现以下错误提示：&lt;/p>
&lt;pre>&lt;code>ubnt@ubnt:/tmp$ add system image openwrt-ramips-mt7621-ubnt-erx-initramfs-kernel.bin
Checking upgrade image...Upgrade image does not support the device. Upgrade failed.
&lt;/code>&lt;/pre>&lt;p>则需要使用老版本的 Kenel 文件&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>刷入，步骤一样。&lt;/p>
&lt;p>当过渡固件刷入后，输入&lt;code>reboot&lt;/code>，重启 ER-X，等待重启完成后，可使用 SSH 重新登陆到 ER-X中。此时 ER-X 中已经是 Open-WRT 过渡固件，所以需要使用 root 用户登录。&lt;/p>
&lt;p>使用 SCP 上传正式固件到 ER-X 中，再登陆 ER-X。&lt;/p>
&lt;pre>&lt;code>$ scp /path/to/openwrt-ramips-mt7621-ubiquiti_edgerouterx-squashfs-sysupgrade.bin root@192.168.1.1:/tmp
$ ssh root@192.168.1.1
&lt;/code>&lt;/pre>&lt;p>进入上传的正式版固件所在的目录，并进行刷写操作。&lt;/p>
&lt;pre>&lt;code>$ cd /tmp
$ sysupgrade openwrt-ramips-mt7621-ubiquiti_edgerouterx-squashfs-sysupgrade.bin
&lt;/code>&lt;/pre>&lt;p>等待一会儿，正式固件即可刷入成功并自动重启。重启完成后，即可登陆 Open-WRT 的 Web 管理界面。因为我们刷入的是 Lean 制作的固件，所以登陆账户为 root，密码为 password，可登陆后自行修改。&lt;/p>
&lt;h2 id="三设置-er-x-为透明网关">三、设置 ER-X 为透明网关&lt;/h2>
&lt;p>设置为透明网关的目的，是让局域网内其他机器能自动加速国外网站的访问，无需特殊设置。其基本操作，是在 Open-WRT 上建立加速服务，由主路由器（假设为 192.168.1.1）将 Open-WRT 的地址下发到局域网中的所有设备上。&lt;/p>
&lt;p>&lt;strong>&lt;img src="https://maolu.one/images/network-structure-1-1024x485.png" alt="network-structure-1-1024x485">&lt;/strong>&lt;/p>
&lt;p>&lt;strong>第一步，先要将 Open-WRT 设置为局域网内的网关。&lt;/strong>&lt;/p>
&lt;p>选取一个局域网内未使用的 IP 地址，将 Open-WRT 的 Lan 口设置为此静态地址，比如：192.168.1.2，子网掩码：255.255.255.0；网关：192.168.1.1，DNS 设置为192.168.1.1。由于我们依旧使用主路由器做 DHCP，所以需要将 Lan 的 DHCP 服务器关掉（忽略此接口）。然后将 Open-WRT 的 Lan 口连接到交换机或路由器的 Lan 口，如果可以的话，在路由器端也将此 Open-WRT 设备的 IP 设置为固定IP（192.168.1.2）。&lt;/p>
&lt;p>&lt;img src="https://maolu.one/images/open-wrt-lan-settings-1200x1322.png" alt="open-wrt-lan-settings-1200x1322">&lt;/p>
&lt;p>&lt;strong>第二步，将主路由器的网关设置为 Open-WRT（192.168.1.2）。&lt;/strong>&lt;/p>
&lt;p>以 Ubnt Unifi 控制器为例，在 &lt;em>&lt;strong>Settings &amp;gt; Networks &amp;gt; LAN &amp;gt; DHCP Controls&lt;/strong>&lt;/em> 中，将 &lt;em>&lt;strong>DHCP Gateway IP&lt;/strong>&lt;/em> 设置为 Open-WRT 的 IP 192.168.1.2。&lt;/p>
&lt;p>&lt;img src="https://maolu.one/images/open-wrt-gateway-settings-1024x832.png" alt="open-wrt-gateway-settings-1024x832">&lt;/p>
&lt;p>为测试是否正常，我们将电脑的网络断开重新连接，观察网关 IP 是否已自动获取为 Open-WRT 的 IP，并测试是否能正常上网。如果网关 IP 已修改，且能正常上网，则可以进行下一步。&lt;/p>
&lt;p>&lt;strong>第三步，在 Open-WRT 上开启国外网站加速功能&lt;/strong>。&lt;/p>
&lt;p>进入 &lt;em>&lt;strong>Open-WRT &amp;gt; 服务 &amp;gt; ShadowsocksR Plus + &amp;gt; 服务器节点&lt;/strong>&lt;/em> 中，添加节点或订阅（订阅需更新），然后进入同页面的的「客户端」中，选择一个节点，点击「保存&amp;amp;应用」，待页面显示「ShadowsocksR Plus+ 运行中」，即可使用电脑测试是否能正常网络加速。&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a href="https://maolu.one/posts/add-ssr-plus-in-lean-openwrt-firmware/" >解决 Lean 固件编译后无 SSR-Plus 的问题&lt;/a> &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>&lt;a href="http://openwrt.jaru.eu.org/openwrt-18.06/targets/ramips/mt7621/openwrt-18.06-snapshot-r7911-f65330d27d-ramips-mt7621-ubnt-erx-initramfs-factory.tar" target="_blank" >老版本的 Kernel 文件&lt;/a> &lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>非对称加密的基本原理</title><link>https://maolu.one/posts/basic-principles-of-asymmetric-encryption/</link><pubDate>Fri, 14 Jun 2019 13:04:01 +0800</pubDate><guid>https://maolu.one/posts/basic-principles-of-asymmetric-encryption/</guid><description>&lt;p>非对称加密算法需要两个密钥：公开密钥（publickey，简称公钥）和私有密钥（privatekey，简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。&lt;/p>
&lt;p>非对称加密算法实现机密信息交换的基本过程是：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>甲方生成一对密钥并将公钥公开；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>需要向甲方发送信息的其他角色(乙方)使用该密钥(甲方的公钥)对机密信息进行加密后再发送给甲方；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>甲方用自己私钥对加密后的信息进行解密。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>甲方想要回复乙方时正好相反，使用乙方的公钥对数据进行加密，同理，乙方使用自己的私钥来进行解密。&lt;/p></description></item><item><title>Nexus 5X 解锁 Recovery 并 ROOT</title><link>https://maolu.one/posts/nexus-5x-unlock-recovery-and-root/</link><pubDate>Mon, 20 Jun 2016 13:04:01 +0800</pubDate><guid>https://maolu.one/posts/nexus-5x-unlock-recovery-and-root/</guid><description>&lt;blockquote>
&lt;p>注意：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>进行以下操作会清除手机所有数据，请谨慎。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>鉴于第一条，建议将手机恢复出厂状态进行操作，避免不必要的错误。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>本文不适用于 Android N 系统，会导致无限 TEAMWIN 界面。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h2 id="一安装-homebrew-和安卓开发者套件">一、安装 Homebrew 和安卓开发者套件&lt;/h2>
&lt;p>安装 Homebrew（已安装的可以忽略此步骤）：&lt;/p>
&lt;pre>&lt;code>$ /usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;
&lt;/code>&lt;/pre>&lt;p>安装安卓开发者套件：&lt;/p>
&lt;pre>&lt;code>$ brew install android-platform-tools
&lt;/code>&lt;/pre>&lt;p>安装完成后，在终端输入 &lt;code>adb version&lt;/code>，应该可以看到 adb 的版本号。&lt;/p>
&lt;h2 id="二下载-supersu-和-twrp-recovery">二、下载 SuperSU 和 TWRP Recovery&lt;/h2>
&lt;p>SuperSU：&lt;a href="http://download.chainfire.eu/supersu" target="_blank" >http://download.chainfire.eu/supersu&lt;/a>&lt;/p>
&lt;p>TWRP：&lt;a href="https://dl.twrp.me/bullhead/" target="_blank" >https://dl.twrp.me/bullhead/&lt;/a>&lt;/p>
&lt;p>SuperSU的包为&lt;code>.zip&lt;/code> 格式，TWRP的包为&lt;code>.img&lt;/code> 格式，两个包下载完后都不要进行解压缩或其他操作，将两个包放到任意一个文件夹中。&lt;/p>
&lt;h2 id="三打开-usb-调试">三、打开 USB 调试&lt;/h2>
&lt;p>在 &lt;em>&lt;strong>设置 &amp;gt; 关于手机&lt;/strong>&lt;/em> 中，拉到底部，连续点击 &lt;em>&lt;strong>版本号&lt;/strong>&lt;/em>，系统会提示 &lt;em>&lt;strong>已开启开发者模式&lt;/strong>&lt;/em>。&lt;/p>
&lt;p>进入 &lt;em>&lt;strong>设置 &amp;gt; 开发者选项&lt;/strong>&lt;/em> 中，打开 &lt;em>&lt;strong>OEM 解锁&lt;/strong>&lt;/em> 和 &lt;em>&lt;strong>USB 调试&lt;/strong>&lt;/em>。使用数据线连接手机，在手机屏幕上会弹出提示是否允许当前计算机进行USB 调试，选择允许。在终端中输入 &lt;code>adb devices&lt;/code>，如果连接正常，在 list of devices attached 下方会显示出手机设备的 id。&lt;/p>
&lt;h2 id="四解锁-bootloader-并输入-twrp-recovery">四、解锁 Bootloader 并输入 TWRP Recovery&lt;/h2>
&lt;blockquote>
&lt;p>注意：解锁将清除手机所有数据。&lt;/p>
&lt;/blockquote>
&lt;p>在 Shell 中，输入&lt;code>adb reboot bootloader&lt;/code>，手机会重启进入 Bootloader 状态。如果之前没有解锁过，在 Bootloader 中，底部的 DEVICE STATE 会显示为 locked 状态。在 Shell 中，输入 &lt;code>fastboot oem unlock&lt;/code>，手机屏幕将会提示是否解锁，使用音量键选中 YES，按电源键确定，手机将解锁。接着进行下一步。&lt;/p>
&lt;p>在 Shell 中，输入 &lt;code>fastboot flash recovery&lt;/code> ，不要回车，将下载的 twrp recovery 拖到 Shell 中，构成完整的命令。按下回车，开始刷入。&lt;/p>
&lt;p>在手机上使用音量上下键，切换到 &lt;em>&lt;strong>Restart bootloader&lt;/strong>&lt;/em> 选项，然后按电源键，重启到 Bootloader，然后再使用音量键，切换到 Recovery mode，按电源键，重启到 Recovery 环境。如果刷入成功，你将看到 TEAMWIN 的 Recovery 启动画面并进入 TWRP Recovery。&lt;/p>
&lt;h2 id="五安装-supersu">五、安装 SuperSU&lt;/h2>
&lt;p>在 TWRP Recovery 中，选择 &lt;em>&lt;strong>Reboot &amp;gt; System&lt;/strong>&lt;/em>，重启手机。将下载的 SuperSU 放到手机的 Download 文件夹中。我在 OS X 中使用的 &lt;em>&lt;strong>Android File Transfer&lt;/strong>&lt;/em> 进行文件传输。&lt;/p>
&lt;p>输入&lt;code>adb reboot recovery&lt;/code>，重启手机，并进入 TWRP Recovery。选择 &lt;em>&lt;strong>Install&lt;/strong>&lt;/em>，进入 Download 文件夹，选择下载的 SuperSU 文件，滑动底部滑块，开始刷入。刷完之后，选择 &lt;em>&lt;strong>Wipe cache/dalvik&lt;/strong>&lt;/em>，然后选择 &lt;em>&lt;strong>Reboot System&lt;/strong>&lt;/em> 进入系统。进入系统后，应用中应该有了 SuperSU，ROOT完成。&lt;/p></description></item><item><title>macOS 使用 ssh key 登陆服务器</title><link>https://maolu.one/posts/login-server-using-ssh-key-on-macos/</link><pubDate>Sat, 18 Jul 2015 13:04:01 +0800</pubDate><guid>https://maolu.one/posts/login-server-using-ssh-key-on-macos/</guid><description>&lt;p>先生成公钥和私钥，在 Mac OSX 终端（或 iTerm 2 等）中进入 ~/.ssh 目录，输入：&lt;/p>
&lt;pre>&lt;code>$ ssh-keygen -t rsa
&lt;/code>&lt;/pre>&lt;p>会询问一些问题，直接全部回车，即可在 ~/.ssh 目录中生成 id_rsa（私钥） 和 id_rsa.pub（公钥）文件。我们需要将公钥上传到 testhost 服务器的 ~/.ssh 目录下面，因为第二种方式中我们已经配置了 testhost 服务器，scp 也能识别这个服务器，所以，可以使用如下命令将文件传输到 testhost 服务器中：&lt;/p>
&lt;pre>&lt;code>$ scp ~/.ssh/id_rsa.pub testhost:~/.ssh/
&lt;/code>&lt;/pre>&lt;p>接下来，用第二种方式登录到 testhost 服务器中，在 ~/.ssh 目录中使用以下命令将 id_rsa.pub 更名为 authorized_keys：&lt;/p>
&lt;pre>&lt;code>$ mv id_rsa.pub authorized_keys
&lt;/code>&lt;/pre>&lt;p>最后确保下文件权限正常：&lt;/p>
&lt;pre>&lt;code>$ chmod 700 ~/.ssh/
$ chmod 600 ~/.ssh/authorized_keys
&lt;/code>&lt;/pre>&lt;p>现在，我们可以在 Mac OSX 的终端中使用 ssh testhost 登录到 testhost 服务器了，无需输入密码，更无需记忆服务器参数。&lt;/p>
&lt;p>如果无法连接，请在服务器的 /etc/ssh/sshd_config 文件中查看 PubkeyAuthentication 的值是否为 yes，如果不是，请修改为 yes ，并使用以下命令重启 ssh 服务：&lt;/p>
&lt;pre>&lt;code>$ /etc/init.d/ssh restart
&lt;/code>&lt;/pre>&lt;p>如果需要禁止密码登录，同样可以编辑 &lt;em>&lt;strong>/etc/ssh/sshd_config&lt;/strong>&lt;/em> 文件中 &lt;em>&lt;strong>PasswordAuthentication&lt;/strong>&lt;/em> 的值为 &lt;em>&lt;strong>no&lt;/strong>&lt;/em> 并 &lt;em>&lt;strong>重启 ssh 服务&lt;/strong>&lt;/em>。&lt;/p>
&lt;p>CentOS 7 可能依然无法登陆，提示：Permission denied (publickey,gssapi-keyex,gssapi-with-mic)。解决方式：&lt;/p>
&lt;pre>&lt;code>$ restorecon -r -vv ～/.ssh/authorized_keys
&lt;/code>&lt;/pre></description></item></channel></rss>